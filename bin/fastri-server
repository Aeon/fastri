#!/usr/bin/env ruby
# fastri-server: serve RI documentation over DRb 
#
# Based on ri-emacs.rb by Kristof Bastiaensen <kristof@vleeuwen.org>
#
#    Copyright (C) 2004,2006 Kristof Bastiaensen
#                  2006      Mauricio Fernandez <mfp@acm.org>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
#----------------------------------------------------------------------
#

require 'rdoc/ri/ri_paths'
require 'rdoc/ri/ri_cache'
require 'rdoc/ri/ri_util'
require 'rdoc/ri/ri_reader'
require 'rdoc/ri/ri_formatter'
require 'rdoc/ri/ri_display'

FASTRI_VERSION = "0.0.1"

class DefaultDisplay
  def full_params(method)
    method.params.split(/\n/).each do |p|
      p.sub!(/^#{method.name}\(/o,'(')
      unless p =~ /\b\.\b/
        p = method.full_name + p
      end
      @formatter.wrap(p) 
      @formatter.break_to_newline
    end
  end
end

class StringRedirectedDisplay < DefaultDisplay
  attr_reader :stringio
  def initialize(*args)
    super(*args)
    reset_stringio
  end

  def puts(*a)
    @stringio.puts(*a)
  end

  def print(*a)
    @stringio.print(*a)
  end

  def reset_stringio
    @stringio = StringIO.new("")
    @formatter.stringio = @stringio
  end
end

class RI::TextFormatter
  def puts(*a); @stringio.puts(*a) end
  def print(*a); @stringio.print(*a) end
end

module FormatterRedirection
  attr_accessor :stringio
  def initialize(*options)
    @stringio = StringIO.new("")
    super
  end
end

class RedirectedAnsiFormatter < RI::AnsiFormatter
  include FormatterRedirection
end

class RedirectedTextFormatter < RI::TextFormatter
  include FormatterRedirection
end


# This class provides the same functionality as RiReader, with some
# improvements:
# * lower memory consumption
# * ability to handle information from different sources separately.
#
# Some operations can be restricted to a given "scope", that is, a
# "RI DB directory". This allows you to e.g. look for all the instance methods
# in String defined by a package.
#
# Such operations take a +scope+ argument, which is either an integer which
# indexes the source in #paths, or a name identifying the source (either
# "system" or a package name).  If <tt>scope == nil</tt>, the information from
# all sources is merged.
class RIIndex 
  # Redefine RI::MethodEntry#full_name to use the following notation:
  # Namespace::Foo.singleton_method (instead of ::). RIIndex depends on this to
  # tell singleton methods apart.
  class ::RI::MethodEntry # :nodoc:
    remove_method :full_name
    def full_name
      res = @in_class.full_name
      unless res.empty?
        if @is_class_method
          res << "."
        else
          res << "#"
        end
      end
      res << @name
    end
  end

  class MethodEntry
    attr_reader :full_name, :name, :index, :source_index

    def initialize(ri_index, fullname, index, source_index)
      # index is the index in ri_index' array
      # source_index either nil (all scopes) or the integer referencing the
      # path (-> we'll do @ri_index.paths[@source_index])
      @ri_index = ri_index
      @full_name = fullname
      @name = fullname[/[.#](.*)$/, 1]
      @index = index
      @source_index = source_index
    end

    # Returns the "fully resolved" file name of the yaml containing our
    # description.
    def path_name
      prefix = @full_name.split(/::|[#.]/)[0..-2]
      case @source_index
      when nil
        ## we'd like to do
        #@ri_index.source_paths_for(self).map do |path|
        #  File.join(File.join(path, *prefix), RI::RiWriter.internal_to_external(@name))
        #end
        # but RI doesn't support merging at the method-level, so
        path = @ri_index.source_paths_for(self).first
        File.join(File.join(path, *prefix), 
                  RI::RiWriter.internal_to_external(@name) + 
                  (singleton_method? ? "-c" : "-i" ) + ".yaml")
      else
        path = @ri_index.paths[@source_index]
        File.join(File.join(path, *prefix), 
                  RI::RiWriter.internal_to_external(@name) +
                  (singleton_method? ? "-c" : "-i" ) + ".yaml")
      end
    end

    def singleton_method?
      /\.[^:]+$/ =~ @full_name
    end

    def instance_method?
      !singleton_method?
    end
  end

  class ClassEntry
    attr_reader :full_name, :name, :index, :source_index

    def initialize(ri_index, fullname, index, source_index)
      @ri_index = ri_index
      @full_name = fullname
      @name = fullname.split(/::/).last
      @index = index
      @source_index = source_index
    end

    # Returns an array of directory names holding the cdesc-Classname.yaml
    # files.
    def path_names
      prefix = @full_name.split(/::/)[0..-1]
      case @source_index
      when nil
        @ri_index.source_paths_for(self).map do |path|
          File.join(path, *prefix)
        end
      else
        [File.join(@ri_index.paths[@source_index], *prefix)]
      end
    end

    # Returns nested classes and modules matching name (non-recursive).
    def contained_modules_matching(name)
      @ri_index.namespaces_under(self, false, @source_index).select do |x|
        x.full_name[name]
      end
    end

    # Returns all nested classes and modules (non-recursive).
    def classes_and_modules
      @ri_index.namespaces_under(self, false, @source_index)
    end

    # Returns nested class or module named exactly +name+ (non-recursive).
    def contained_class_named(name)
      contained_modules_matching(name).find{|x| x.name == name}
    end

    # Returns instance or singleton methods matching name (non-recursive).
    def methods_matching(name, is_class_method)
      @ri_index.methods_under(self, false, @source_index).select do |meth|
        meth.name[name] &&
          (is_class_method ? meth.singleton_method? : meth.instance_method?)
      end
    end

    # Returns instance or singleton methods matching name (recursive).
    def recursively_find_methods_matching(name, is_class_method)
      @ri_index.methods_under(self, true, @source_index).select do |meth|
        meth.name[name] && 
          (is_class_method ? meth.singleton_method? : meth.instance_method?)
      end
    end

    # Returns all methods, both instance and singleton (non-recursive).
    def all_method_names
      @ri_index.methods_under(self, false, @source_index).map{|meth| meth.full_name}
    end
  end

  class TopLevelEntry < ClassEntry
    def methods_matching(name, is_class_method)
      recursively_find_methods_matching(name, is_class_method)
    end

    def module_named(name)

    end
  end

  attr_reader :paths

  def initialize(paths = nil)
    @paths = paths || RI::Paths::PATH
    @gem_names = paths.map do |p|
      fullp = File.expand_path(p)
      gemname = nil
      Gem.path.each do |gempath|
        re = %r!^#{Regexp.escape(File.expand_path(gempath))}/doc/!
        if re =~ fullp
          gemname = fullp.gsub(re,"")[%r{^[^/]+}]
          break
        end
      end
      gemname ? gemname : "system"
    end
    rebuild_index
  end

  def rebuild_index
    methods    = Hash.new{|h,k| h[k] = []}
    namespaces = methods.clone 
    @paths.each_with_index do |path, source_index|
      ri_reader = RI::RiReader.new(RI::RiCache.new(path))
      obtain_classes(ri_reader.top_level_namespace.first).each{|name| namespaces[name] << source_index }
      obtain_methods(ri_reader.top_level_namespace.first).each{|name| methods[name] << source_index }
    end
    @method_array = methods.sort_by{|h,k| h}.map do |name, sources|
      "#{name} #{sources.map{|x| x.to_s}.join(' ')}"
    end
    @namespace_array = namespaces.sort_by{|h,k| h}.map do |name, sources|
      "#{name} #{sources.map{|x| x.to_s}.join(' ')}"
    end

=begin
    puts "@method_array: #{@method_array.size}"
    puts "@namespace_array: #{@namespace_array.size}"
    puts @method_array.inject(0){|s,x| s + x.size}
    puts @namespace_array.inject(0){|s,x| s + x.size}
=end
  end

  # Serializes index to the given IO.
  def dump_index(anIO = $stdout)
    anIO.puts "Sources:"
    @paths.zip(@gem_names).each{|p,g| anIO.puts "%-30s  %s" % [g, p]}
    anIO.puts "=" * 80
    anIO.puts "Namespaces:"
    anIO.puts @namespace_array
    anIO.puts "=" * 80
    anIO.puts "Methods:"
    anIO.puts @method_array
  end

  # Returns an array with the top level namespace.
  def top_level_namespace(scope = nil)
    [TopLevelEntry.new(self, "", 0, scope ? scope_to_sindex(scope) : nil)]
  end

  # Returns an array of ClassEntry objects whose names match +target+, and
  # which correspond to the namespaces contained in +namespaces+.
  # +namespaces+ is an array of ClassEntry objects.
  def lookup_namespace_in(target, namespaces)
    result = []
    namespaces.each do |ns|
      result.concat(ns.contained_modules_matching(target))
    end
    result
  end

  # Returns the ClassDescription associated to the given +full_name+.
  def find_class_by_name(full_name, scope = nil)
    entry = get_entry(@namespace_array, full_name, ClassEntry, scope)
    return nil unless entry && entry.full_name == full_name
    get_class(entry)
  end
  
  # Returns the MethodDescription associated to the given +full_name+.
  # Only the first definition is returned when <tt>scope = nil</tt>.
  def find_method_by_name(full_name, scope = nil)
    entry = get_entry(@method_array, full_name, MethodEntry, scope)
    return nil unless entry && entry.full_name == full_name
    get_method(entry)
  end

  # Returns an array of MethodEntry objects, corresponding to the methods in
  # the ClassEntry objects in the +namespaces+ array.
  def find_methods(name, is_class_method, namespaces)
    result = []
    namespaces.each do |ns|
      result.concat ns.methods_matching(name, is_class_method)
    end
    result
  end

  # Return the MethodDescription for a given MethodEntry
  # by deserializing the YAML.
  def get_method(method_entry)
    path = method_entry.path_name
    File.open(path) { |f| RI::Description.deserialize(f) }
  end

  # Return a ClassDescription for a given ClassEntry.
  def get_class(class_entry)
    result = nil
    for path in class_entry.path_names
      path = RI::RiWriter.class_desc_path(path, class_entry)
      desc = File.open(path) {|f| RI::Description.deserialize(f) }
      if result
        result.merge_in(desc)
      else
        result = desc
      end
    end
    result
  end

  # Return the names of all classes and modules.
  def full_class_names(scope = nil)
    entries(@namespace_array, scope)
  end

  # Return the names of all methods.
  def full_method_names(scope = nil)
    entries(@method_array, scope)
  end

  # Return a list of all classes, modules, and methods.
  def all_names(scope = nil)
    full_class_names(scope).concat(full_method_names(scope))
  end

  # Returns array of ClassEntry objects under class_entry_or_name
  # (either String or ClassEntry) in the hierarchy.
  def namespaces_under(class_entry_or_name, recursive, scope = nil)
    case class_entry_or_name
    when ClassEntry
      class_entry = class_entry_or_name
    else
      class_entry = get_entry(@namespace_array, class_entry_or_name, ClassEntry, scope)
    end
    return [] unless class_entry
    ret = []
    re1, re2 = matching_regexps(class_entry.full_name)
    (class_entry.index+1...@namespace_array.size).each do |i|
      entry = @namespace_array[i]
      break unless re1 =~ entry
      next if !recursive && re2 !~ entry 
      if scope
        sources = namespace_sources(i)
        if sources.include?(sindex = scope_to_sindex(scope))
          ret << ClassEntry.new(self, entry[/\S+/], i, sindex)
        end
      else
        ret << ClassEntry.new(self, entry[/\S+/], i, nil)
      end
    end
    ret
  end

  # Returns array of MethodEntry objects under class_entry_or_name
  # (either String or ClassEntry) in the hierarchy.
  def methods_under(class_entry_or_name, recursive, scope = nil)
    case class_entry_or_name
    when ClassEntry
      full_name = class_entry_or_name.full_name
    else
      full_name = class_entry_or_name
    end
    method_entry = get_entry(@method_array, full_name, MethodEntry, scope)
    return [] unless method_entry
    ret = []
    re1, re2 = matching_regexps(full_name)
    (method_entry.index+1...@method_array.size).each do |i|
      entry = @method_array[i]
      break unless re1 =~ entry
      next if !recursive && re2 !~ entry 
      if !recursive
        next unless re2 =~ entry
      end
      if scope
        sources = method_sources(i)
        if sources.include?(sindex = scope_to_sindex(scope))
          ret << MethodEntry.new(self, entry[/\S+/], i, sindex)
        end
      else
        ret << MethodEntry.new(self, entry[/\S+/], i, nil)
      end
    end
    ret
  end

  # Returns array of Strings corresponding to the base directories of all the
  # sources fo the given entry_or_name.
  def source_paths_for(entry_or_name)
    case entry_or_name
    when ClassEntry
      namespace_sources(entry_or_name.index).map{|i| @paths[i] }
    when MethodEntry
      method_sources(entry_or_name.index).map{|i| @paths[i]}
    when nil
      []
    else
      case entry_or_name
      when /[#.]\S+/
        method_entry = get_entry(@method_array, entry_or_name, MethodEntry, nil)
        source_paths_for(method_entry)
      else
        class_entry = get_entry(@namespace_array, entry_or_name, ClassEntry, nil)
        source_paths_for(class_entry)
      end
    end
  end

  private
  def namespace_sources(index)
    @namespace_array[index][/\S+ (.*)/,1].split(/\s+/).map{|x| x.to_i}
  end

  def method_sources(index)
    @method_array[index][/\S+ (.*)/,1].split(/\s+/).map{|x| x.to_i}
  end

  def entries(array, scope)
    if scope
      wanted_sidx = scope_to_sindex(scope)
      chosen = array.select{|x| x[/ (.*)/, 1].map{|x| x.to_i}.include? wanted_sidx }
    else
      chosen = array
    end
    chosen.map{|x| x[/(\S+)/]}
  end

  def matching_regexps(prefix)
    if prefix.empty?
      [//, /^[^:]+ /]
    else
      [/^#{Regexp.escape(prefix)}/, /^#{Regexp.escape(prefix)}(::|[#.])[^:]+ / ]
    end
  end

  def scope_to_sindex(scope)
    case scope
    when Integer
      scope
    else
      @gem_names.index(scope)
    end
  end

  def get_entry(array, fullname, klass, scope = nil)
    index = binary_search(array, fullname)
    return nil unless index
    entry = array[index]
    sources = entry[/\S+ (.*)/,1].split(/\s+/).map{|x| x.to_i}
    if scope
      wanted_sidx = scope_to_sindex(scope)
      return nil unless wanted_sidx
      return nil unless sources.include?(wanted_sidx)
      return klass.new(self, entry[/\S+/], index, wanted_sidx)
    end
    klass.new(self, entry[/\S+/], index, nil)
  end

  def binary_search(array, name, from = 0, to = array.size - 1)
    middle = (from + to) / 2
    pivot = array[middle][/\S+/]
    if from == to
      if pivot.index(name) == 0
        from
      else
        nil
      end
    elsif name <= pivot
      binary_search(array, name, from, middle)
    elsif name > pivot
      binary_search(array, name, middle+1, to)
    end
  end
    
  def obtain_classes(namespace, res = [])
    subnamespaces = namespace.classes_and_modules
    subnamespaces.each do |ns|
      res << ns.full_name
      obtain_classes(ns, res)
    end
    res
  end

  def obtain_methods(namespace, res = [])
    subnamespaces = namespace.classes_and_modules
    subnamespaces.each do |ns|
      res.concat ns.all_method_names
      obtain_methods(ns, res)
    end
    res
  end
end

class RIService
   Options = Struct.new(:formatter, :use_stdout, :width)
   QueryData = Struct.new(:desc, :namespaces, :methods)

   def initialize(ri_reader)
     @ri_reader = ri_reader
   end

   def lookup_keyword(keyw)
     ret = QueryData.new
     begin
       ret.desc = NameDescriptor.new(keyw)
     rescue RiError => e
       return nil
     end
     ret.namespaces = @ri_reader.top_level_namespace

     container = ret.namespaces
     for class_name in ret.desc.class_names
       return nil if container.empty?
       ret.namespaces = @ri_reader.lookup_namespace_in(class_name, container)
       container = ret.namespaces.find_all {|m| m.name == class_name}
     end

      if ret.desc.method_name.nil?
         if [?., ?:, ?#].include? keyw[-1]
            ret.namespaces = container
            is_class_method = case keyw[-1]
                              when ?.: nil
                              when ?:: true
                              when ?#: false
                              end
            ret.methods = @ri_reader.find_methods("", is_class_method, container)
            return nil if ret.methods.empty?
         else
            ret.namespaces = ret.namespaces.find_all{ |n| n.name.index(class_name).zero? }
            return nil if ret.namespaces.empty?
            ret.methods = nil
         end
      else
         return nil if container.empty?
         ret.namespaces = container
         ret.methods = @ri_reader.find_methods(ret.desc.method_name,
                                               ret.desc.is_class_method,
                                               container)
         ret.methods = ret.methods.find_all do |m|
           m.name.index(ret.desc.method_name).zero?
         end
         return nil if ret.methods.empty?
      end
      
      ret
   end

   def completion_list(keyw)
      return @ri_reader.full_class_names if keyw == ""
      
      return nil unless (qdata = lookup_keyword(keyw))

      if qdata.methods.nil?
         return qdata.namespaces.map{ |n| n.full_name }
      elsif qdata.desc.class_names.empty?
         return qdata.methods.map { |m| m.name }.uniq
      else
         return qdata.methods.map { |m| m.full_name }
      end
   end

   def info(keyw, type = :ansi)
      return nil unless (qdata = lookup_keyword(keyw))
      
      if qdata.methods.nil?
         qdata.namespaces = qdata.namespaces.find_all { |n| n.full_name == qdata.desc.full_class_name }
         return nil if qdata.namespaces.empty?
         klass = @ri_reader.get_class(qdata.namespaces[0])
         capture_stdout(display(type)) do |display|
           display.display_class_info(klass, @ri_reader)
         end
      else
         qdata.methods = qdata.methods.find_all { |m| m.name == qdata.desc.method_name }
         return nil if qdata.methods.empty?
         meth = @ri_reader.get_method(qdata.methods[0])
         capture_stdout(display(type)) do |display|
           display.display_method_info(meth)
         end
      end
   end

   def args(keyw, type = :ansi)
      return nil unless (qdata = lookup_keyword(keyw))
      return nil unless qdata.desc.class_names.empty?

      qdata.methods = qdata.methods.find_all { |m| m.name == qdata.desc.method_name }
      return nil if qdata.methods.empty?
      params_text = ""
      qdata.methods.each do |m|
        meth = @ri_reader.get_method(m)
        params_text << capture_stdout(display(type)) do |display|
          display.full_params(meth)
        end
      end
      params_text
   end

   # return a list of classes for the method keyw
   # return nil if keyw has already a class
   def class_list(keyw, rep='\1')
      return nil unless (qdata = lookup_keyword(keyw))
      return nil unless qdata.desc.class_names.empty?

      qdata.methods = qdata.methods.find_all { |m| m.name == qdata.desc.method_name }

      return qdata.methods.map{|m| m.full_name.sub(/(.*)(#|(::)).*/, rep) }.uniq
   end

   # flag means (#|::) 
   # return a list of classes and flag for the method keyw
   # return nil if keyw has already a class
   def class_list_with_flag(keyw)
     class_list(keyw, '\1\2')
   end

   private
   def display(type)
      options = Options.new
      options.use_stdout = true
      case type.to_sym
      when :ansi
        options.formatter = RedirectedAnsiFormatter
      else
        options.formatter = RedirectedTextFormatter
      end
      options.width = 72
      StringRedirectedDisplay.new(options)
   end

   def capture_stdout(display)
     yield display
     display.stringio.string
   end
end

#{{{ Main program

if $0 == __FILE__

require 'optparse'

options = {:allowed_hosts => ["127.0.0.1"], :addr => "127.0.0.1"}
OptionParser.new do |opts|
  opts.banner = "Usage: fastri-server.rb [options]"

  opts.on("-a", "--allow HOST", "Allow connections from HOST.",
          "(default: 127.0.0.1)") do |host|
    options[:allowed_hosts] << host
  end

  opts.on("-s", "--bind ADDR", "Listen to connections on ADDR.",
          "(default: 127.0.0.1)") do |addr|
    options[:addr] = addr
  end

  opts.on("-h", "--help", "Show this help message") do 
    puts opts
    exit
  end
end.parse!

# The local environment is trusted --- what we don't trust is what would come
# from the DRb connection. This way the RIService will be untainted, and we
# will be able to use it with $SAFE = 1.
ObjectSpace.each_object{|obj| obj.untaint unless obj.frozen? }

paths = [ RI::Paths::SYSDIR, RI::Paths::SITEDIR, RI::Paths::HOMEDIR ].find_all do |p|
  p && File.directory?(p)
end
begin
  require 'rubygems'
  paths.concat Dir["#{Gem.path}/doc/*/ri"]
rescue LoadError
end 

puts "Building index."
t0 = Time.new
#ri_reader = RI::RiReader.new(RI::RiCache.new(paths))
ri_reader = RIIndex.new(paths)
puts "Needed #{Time.new - t0} seconds"

service = RIService.new(ri_reader)
GC.start

require 'rinda/ring'
require 'rinda/tuplespace'
require 'drb/acl'

class RIService
  include DRbUndumped
end

#{{{ start DRb service
acl_opt = ["deny", "all"]
options[:allowed_hosts].each{|host| acl_opt.concat ["allow", host.strip]}
acl = ACL.new(acl_opt)
DRb.install_acl(acl)

drb_addr = "druby://#{options[:addr]}:0"
DRb.start_service(drb_addr)

$SAFE = 1

$stdout.sync = true
begin
  puts "Looking for Ring server..."
  finder = Rinda::RingFinger.new
  service_ts = finder.lookup_ring_any(2)
  puts "Located Ring server at #{service_ts.__drburi}"
rescue Exception
  puts "No Ring server found, starting my own."
  service_ts = Rinda::TupleSpace.new
  ring_server = Rinda::RingServer.new(service_ts)
end

begin
  service_ts.write([:name, :FastRI, service, 'FastRI documentation'], Rinda::SimpleRenewer.new)
rescue Exception
  puts <<EOF
The FastRI service could not be registered in the Ring.
This is probably due to the Ring being bound to an unreachable address.
You can specify which address the Ring should be bound to with
  fastri-server --bind ADDRESS --allow ADDRESS
EOF
  exit
end

# {{{ Init message
require 'enumerator'
puts "FastRI #{FASTRI_VERSION} listening on #{DRb.uri}"
puts "ACL:"
acl_opt.each_slice(2){|action, host| puts "%-5s %s" % [action, host]}

# {{{ GC periodically
# keeps the process hot too :)
Thread.new do 
  loop do
    GC.start
    sleep 300
  end
end

if $DEBUG
  # trying to see where our memory is going
  population = Hash.new{|h,k| h[k] = [0,0]}
  array_sizes = Hash.new{|h,k| h[k] = 0}
  ObjectSpace.each_object do |object|
    size = case object   # rough estimates
           when Array
             array_sizes[object.size / 10] += 1
             case object.size
             when 0..16
               20 + 64
             else
               20 + 4 * object.size * 1.5
             end
           when Hash;    40 + 4 * [object.size / 5, 11].max + 16 * object.size
           when String;  30 + object.size
           else 120 # the iv_tbl, etc
           end
    count, tsize = population[object.class] 
    population[object.class] = [count + 1, tsize + size]
  end

  population.sort_by{|k,(c,s)| s}.reverse[0..10].each do |klass, (count, bytes)|
    puts "%-20s  %7d  %9d" % [klass, count, bytes]
  end

  puts "Array sizes:"
  array_sizes.sort.each{|k,v| puts "%5d  %6d" % [k * 10, v]}
end

DRb.thread.join

end # main prog
# vi: set sw=2 expandtab:
